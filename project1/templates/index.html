{% extends 'base.html' %}
{% load static %}

{% block extra_css %}
  <link rel="stylesheet" href="{% static 'project2.css' %}">
{% endblock %}

{% block content %}
<div class="project2">
  
  <a href="{% url 'home:index' %}" class="home-button">Home</a>

  <h1>Project 1: Automated Machine Learning</h1>

  <p class="lead">
    This project provides an interactive interface for automated machine learning. 
    You can upload a dataset, explore it through visualizations, and train different ML models 
    for both classification and regression tasks.
  </p>

  <!-- 1) Upload -->
  <section>
    <h2>Upload CSV File</h2>
    <form method="post" enctype="multipart/form-data">
      {% csrf_token %}
      <input type="file" name="csv_file" accept=".csv" required>
      <button type="submit">Upload</button>
    </form>
    {% if message %}
      <p class="status">{{ message }}</p>
    {% endif %}
    {% if error_msg %}
      <p class="status error">{{ error_msg }}</p>
    {% endif %}
  </section>

  {% if data_preview %}
    <!-- 2) Preview -->
    <section>
      <h2>Dataset Preview</h2>
      <div class="data-preview-container">
        <style>
          .data-preview-container { 
              width: 80% !important;              
              margin: 10px auto 30px !important;  
              max-height: 300px !important;
              padding: 12px !important;
              border: none !important;
              background: transparent !important;
              box-shadow: none !important;
              overflow-x: auto !important;
          }
          .data-preview-container table,
          .data-preview-container .dataframe {
              width: 100% !important;              
              table-layout: fixed !important;      
              border-collapse: collapse !important;
              font-size: 11px !important;
              word-wrap: break-word !important;
              background: transparent !important;
          }
          .data-preview-container th,
          .data-preview-container td {
              padding: 4px 6px !important;
              border: 1px solid #ddd !important;
              text-align: center !important;
              font-size: 13px !important;
          }
        </style>
        {{ data_preview|safe }}
      </div>
    </section>
  {% endif %}

  {% if show_visualize or show_train_form %}
    <!-- 3) Visualize -->
    <hr>
    <section>
      <h2>Select Task and Target Column</h2>
      <form method="post">
        {% csrf_token %}
        <label for="target_column">Target Column:</label>
        <select name="target_column" id="target_column" required>
          {% for col in columns %}
            <option value="{{ col }}" {% if col == target_column %}selected{% endif %}>{{ col }}</option>
          {% endfor %}
        </select><br><br>

        <label for="task">Problem Type:</label>
        <select name="task" id="task-select" required>
          <option value="classification" {% if task == "classification" %}selected{% endif %}>Classification</option>
          <option value="regression" {% if task == "regression" %}selected{% endif %}>Regression</option>
        </select><br><br>

        <label for="x_feature">X Feature:</label>
        <select name="x_feature" id="x_feature" required>
          {% for col in columns %}
            <option value="{{ col }}" {% if col == x_feature %}selected{% endif %}>{{ col }}</option>
          {% endfor %}
        </select><br><br>

        <label for="y_feature">Y Feature (optional for regression, required for classification):</label>
        <select name="y_feature" id="y_feature">
          <option value="">-- Optional --</option>
          {% for col in columns %}
            <option value="{{ col }}" {% if col == y_feature %}selected{% endif %}>{{ col }}</option>
          {% endfor %}
        </select><br><br>

        <button type="submit" name="visualize" value="1">Visualize</button>
      </form>
    </section>
  {% endif %}

  {% if plot_url %}
    <section>
      <h2>Generated Plot</h2>
      <img src="{{ plot_url }}" alt="Generated plot" style="max-width: 600px; border: 1px solid #ccc;">
    </section>
  {% endif %}

  {% if show_train_form %}
    <!-- 4) Train -->
    <hr>
    <section>
      <h2>Train a Model</h2>
      <form id="train-form" method="post">
        {% csrf_token %}

        <label for="task-train">Problem Type:</label>
        <select name="task" id="task-train" required>
          <option value="classification" {% if task == "classification" %}selected{% endif %}>Classification</option>
          <option value="regression" {% if task == "regression" %}selected{% endif %}>Regression</option>
        </select><br><br>

        <label for="target_column-train">Target Column:</label>
        <select name="target_column" id="target_column-train" required>
          {% for col in columns %}
            <option value="{{ col }}" {% if col == target_column %}selected{% endif %}>{{ col }}</option>
          {% endfor %}
        </select><br><br>

        <fieldset>
          <legend>Split</legend>
          <label for="split-mode">Mode:</label>
          <select name="split_mode" id="split-mode">
            <option value="tt" selected>Train / Test</option>
            <option value="tvt">Train / Validation / Test</option>
          </select><br><br>

          <label for="test-size">Test size (0–1):</label>
          <input id="test-size" name="test_size" type="number" min="0.05" max="0.95" step="0.01" value="0.2"><br><br>

          <div id="val-size-wrap" style="display:none;">
            <label for="val-size">Validation size (0–1):</label>
            <input id="val-size" name="val_size" type="number" min="0.05" max="0.9" step="0.01" value="0.1"><br><br>
          </div>

          <label><input type="checkbox" name="shuffle" id="shuffle" checked> Shuffle</label><br><br>
          <div id="stratify-wrap">
            <label><input type="checkbox" name="stratify" id="stratify" checked> Stratify (classification only)</label><br><br>
          </div>

          <label for="random-state">Random state:</label>
          <input id="random-state" name="random_state" type="number" step="1" placeholder="None"><br><br>
        </fieldset>
        <br>

        <label for="model_type">Choose Model:</label>
        <select name="model_type" id="model-select" required>
          <option value="" disabled>Select a model</option>
        </select><br><br>

        <div id="hp-fields" class="hp-container">
          <p class="muted">Pick a model to see its hyperparameters.</p>
        </div>

        <!-- Inline warning area (hidden until needed) -->
        <div id="hp-warning" class="status error"
             style="display:none; margin-top:8px;">
        </div>

        <button type="submit" name="train" value="1" id="train-btn">Train Model</button>
        <button type="button" id="change-btn" class="btn btn-secondary"
                style="display:none; margin:12px auto 0; display:block; text-align:center;">
          Change selection
        </button>
      </form>

      <script>
      document.addEventListener("DOMContentLoaded", function() {
        const modelSelect  = document.getElementById("model-select");
        const taskSelectV  = document.getElementById("task-train");
        const hpFields     = document.getElementById("hp-fields");
        const warningBox   = document.getElementById("hp-warning");
        const splitMode    = document.getElementById("split-mode");
        const valWrap      = document.getElementById("val-size-wrap");
        const stratifyWrap = document.getElementById("stratify-wrap");
        const trainBtn     = document.getElementById("train-btn");
        const changeBtn    = document.getElementById("change-btn");

        // Prefill state from backend
        const PRE_SELECTED_MODEL = "{{ selected_model_type|default:'' }}";
        let PRE_HP = {};
        try { PRE_HP = JSON.parse('{{ selected_hp_json|default:"{}"|safe }}'); } catch(e) { PRE_HP = {}; }

        const MODEL_OPTIONS = {
          classification: [
            { value: "logistic", text: "Logistic Regression" },
            { value: "dt", text: "Decision Tree" },
            { value: "rf", text: "Random Forest" },
            { value: "knn", text: "K-Nearest Neighbors" },
            { value: "svm", text: "Support Vector Machine (SVC)" },
            { value: "nb", text: "Naive Bayes" }
          ],
          regression: [
            { value: "lasso", text: "Lasso Regression" },
            { value: "ridge", text: "Ridge Regression" },
            { value: "rf", text: "Random Forest Regressor" },
            { value: "xgb", text: "XGBoost Regressor" },
            { value: "lgbm", text: "LightGBM Regressor" },
            { value: "svm", text: "Support Vector Regressor" },
            { value: "knn", text: "KNN Regressor" }
          ]
        };

        const HP_SCHEMA = {
          classification: {
            logistic: {
              C: { type: "float", min: 0.0001, max: 1000, default: 1.0,
                   desc: "(Inverse regularization, 0.0001–1000; higher = less reg.)" },
              penalty: { type: "choice", choices: ["l2", "l1", "elasticnet"], default: "l2",
                   desc: "(Regularization type: l2/l1/elasticnet)" },
              solver: { type: "choice", choices: ["lbfgs","liblinear","saga"], default: "lbfgs",
                   desc: "(Optimizer; l1 needs liblinear/saga; elasticnet needs saga)" },
              l1_ratio: { type: "float", min: 0.0, max: 1.0, default: 0.5,
                   desc: "(Only if penalty=elasticnet; 0–1)" },
              max_iter: { type: "int", min: 50, max: 5000, step: 50, default: 200,
                   desc: "(Max iterations, 50–5000)" }
            },
            dt: {
              criterion: { type: "choice", choices: ["gini","entropy","log_loss"], default: "gini",
                   desc: "(Split metric: gini/entropy/log_loss)" },
              max_depth: { type: "int_or_none", min: 1, max: 200, step: 1, default: null,
                   desc: "(Tree depth, 1–200; blank=None)" },
              min_samples_split: { type: "int", min: 2, max: 50, step: 1, default: 2,
                   desc: "(Min samples to split, 2–50)" },
              min_samples_leaf: { type: "int", min: 1, max: 50, step: 1, default: 1,
                   desc: "(Min samples at leaf, 1–50)" }
            },
            rf: {
              n_estimators: { type: "int", min: 10, max: 2000, step: 10, default: 100,
                   desc: "(Number of trees, 10–2000)" },
              max_depth: { type: "int_or_none", min: 1, max: 200, step: 1, default: null,
                   desc: "(Tree depth, 1–200; blank=None)" },
              min_samples_split: { type: "int", min: 2, max: 50, step: 1, default: 2,
                   desc: "(Min samples to split, 2–50)" },
              min_samples_leaf: { type: "int", min: 1, max: 50, step: 1, default: 1,
                   desc: "(Min samples at leaf, 1–50)" }
            },
            knn: {
              n_neighbors: { type: "int", min: 1, max: 100, step: 1, default: 5,
                   desc: "(Neighbors, 1–100)" },
              weights: { type: "choice", choices: ["uniform","distance"], default: "uniform",
                   desc: "(Voting: uniform/distance)" }
            },
            svm: {
              C: { type: "float", min: 0.0001, max: 1000, default: 1.0,
                   desc: "(Regularization, 0.0001–1000; higher = harder margin)" },
              kernel: { type: "choice", choices: ["rbf","linear","poly","sigmoid"], default: "rbf",
                   desc: "(Kernel type: rbf/linear/poly/sigmoid)" },
              gamma: { type: "choice", choices: ["scale","auto"], default: "scale",
                   desc: "(Kernel coef: scale/auto)" }
            },
            nb: {
              var_smoothing: { type: "float", min: 1e-12, max: 1e-6, default: 1e-9,
                   desc: "(Stability term, 1e-12–1e-6)" }
            }
          },
          regression: {
            lasso: {
              alpha: { type: "float", min: 0.0, max: 10, default: 1.0,
                   desc: "(L1 regularization ≥0; typical 0–1)" },
              max_iter: { type: "int", min: 50, max: 20000, step: 50, default: 1000,
                   desc: "(Max iterations, 50–20000)" }
            },
            ridge: {
              alpha: { type: "float", min: 0.0, max: 10, default: 1.0,
                   desc: "(L2 regularization ≥0; typical 0–10)" },
              solver: { type: "choice", choices: ["auto","svd","cholesky","lsqr","sparse_cg","sag","saga"], default: "auto",
                   desc: "(Optimization solver)" }
            },
            rf: {
              n_estimators: { type: "int", min: 10, max: 2000, step: 10, default: 100,
                   desc: "(Number of trees, 10–2000)" },
              max_depth: { type: "int_or_none", min: 1, max: 200, step: 1, default: null,
                   desc: "(Tree depth, 1–200; blank=None)" },
              min_samples_split: { type: "int", min: 2, max: 50, step: 1, default: 2,
                   desc: "(Min samples to split, 2–50)" },
              min_samples_leaf: { type: "int", min: 1, max: 50, step: 1, default: 1,
                   desc: "(Min samples at leaf, 1–50)" }
            },
            xgb: {
              n_estimators: { type: "int", min: 10, max: 5000, step: 10, default: 200,
                   desc: "(Boosting rounds, 10–5000)" },
              max_depth: { type: "int", min: 1, max: 20, step: 1, default: 6,
                   desc: "(Tree depth, 1–20)" },
              learning_rate: { type: "float", min: 0.001, max: 1, default: 0.1,
                   desc: "(Shrinkage, 0.001–1; typical 0.01–0.3)" },
              subsample: { type: "float", min: 0.1, max: 1, default: 1.0,
                   desc: "(Row sampling per tree, 0.1–1)" },
              colsample_bytree: { type: "float", min: 0.1, max: 1, default: 1.0,
                   desc: "(Feature sampling per tree, 0.1–1)" }
            },
            lgbm: {
              n_estimators: { type: "int", min: 10, max: 5000, step: 10, default: 200,
                   desc: "(Boosting rounds, 10–5000)" },
              max_depth: { type: "int_or_none", min: 1, max: 128, step: 1, default: null,
                   desc: "(Tree depth, 1–128; blank=None)" },
              learning_rate: { type: "float", min: 0.001, max: 1, default: 0.1,
                   desc: "(Shrinkage, 0.001–1; typical 0.01–0.3)" },
              num_leaves: { type: "int", min: 2, max: 1024, step: 1, default: 31,
                   desc: "(Leaves per tree, 2–1024)" }
            },
            svm: {
              C: { type: "float", min: 0.0001, max: 1000, default: 1.0,
                   desc: "(Regularization, 0.0001–1000)" }
            },
            knn: {
              n_neighbors: { type: "int", min: 1, max: 100, step: 1, default: 5,
                   desc: "(Neighbors, 1–100)" }
            }
          }
        };

        function updateSplitVisibility() {
          valWrap.style.display = splitMode.value === "tvt" ? "block" : "none";
          stratifyWrap.style.display = taskSelectV.value === "classification" ? "block" : "none";
        }

        // helper to get current HP control value
        function getHP(name) {
          const el = document.getElementById("hp_" + name);
          if (!el) return undefined;
          if (el.type === "checkbox") return el.checked ? "true" : "false";
          return el.value;
        }

        function setWarning(msg) {
          if (msg) {
            warningBox.textContent = "Incompatible hyperparameters: " + msg;
            warningBox.style.display = "block";
            trainBtn.disabled = true;
          } else {
            warningBox.textContent = "";
            warningBox.style.display = "none";
            trainBtn.disabled = false;
          }
        }

        function validateCombos() {
          setWarning("");
          const task = taskSelectV.value;
          const model = modelSelect.value;
          if (task !== "classification" || model !== "logistic") return;

          const penalty = (getHP("penalty") || "l2").toLowerCase();
          const solver  = (getHP("solver") || "lbfgs").toLowerCase();
          const l1r     = getHP("l1_ratio");
          const cVal    = getHP("C");

          const allowed = {
            lbfgs: new Set(["l2"]),
            liblinear: new Set(["l1","l2"]),
            saga: new Set(["l1","l2","elasticnet"])
          };

          if (!allowed[solver]) {
            return setWarning("solver='" + solver + "' is not supported. Use lbfgs, liblinear or saga.");
          }
          if (!allowed[solver].has(penalty)) {
            return setWarning("penalty='" + penalty + "' is incompatible with solver='" + solver + "'.");
          }
          if (penalty === "elasticnet") {
            if (solver !== "saga") {
              return setWarning("elasticnet penalty requires solver='saga'.");
            }
            if (l1r === undefined || l1r === "" || isNaN(Number(l1r))) {
              return setWarning("elasticnet requires l1_ratio (0–1).");
            }
            const r = Number(l1r);
            if (r < 0 || r > 1) {
              return setWarning("l1_ratio must be between 0 and 1.");
            }
          }
          if (cVal !== undefined && cVal !== "" && !isNaN(Number(cVal))) {
            if (Number(cVal) <= 0) {
              return setWarning("C must be > 0.");
            }
          }
          setWarning("");
        }

        function renderModels() {
          const task = taskSelectV.value;
          const options = MODEL_OPTIONS[task] || [];
          modelSelect.innerHTML = "";

          options.forEach(m => {
            const o = document.createElement("option");
            o.value = m.value; o.textContent = m.text;
            modelSelect.appendChild(o);
          });

          // Prefill previously selected model (if any)
          if (PRE_SELECTED_MODEL && options.some(x => x.value === PRE_SELECTED_MODEL)) {
            modelSelect.value = PRE_SELECTED_MODEL;
          } else {
            modelSelect.selectedIndex = 0;
          }
        }

        // Render HP fields and prefill from PRE_HP once at init
        let didPrefillOnce = false;
        function renderHyperparams() {
          const task = taskSelectV.value;
          const model = modelSelect.value;
          const schema = (HP_SCHEMA[task] && HP_SCHEMA[task][model]) ? HP_SCHEMA[task][model] : {};
          hpFields.innerHTML = "";

          if (!schema || Object.keys(schema).length === 0) {
            hpFields.innerHTML = '<p class="muted">No hyperparameters for this model.</p>';
            validateCombos();
            return;
          }

          const grid = document.createElement("div");
          grid.className = "hp-grid";

          Object.entries(schema).forEach(([name, spec]) => {
            const fieldId = `hp_${name}`;
            const wrap = document.createElement("div");
            wrap.className = "hp-item";

            const label = document.createElement("label");
            label.setAttribute("for", fieldId);
            label.textContent = name;
            if (spec.desc) {
              const small = document.createElement("small");
              small.style.display = "block";
              small.style.color = "#666";
              small.style.marginTop = "2px";
              small.textContent = spec.desc;
              label.appendChild(small);
            }

            let input;
            if (spec.type === "choice") {
              input = document.createElement("select");
              input.name = fieldId; input.id = fieldId;
              (spec.choices || []).forEach(c => {
                const opt = document.createElement("option");
                opt.value = c === null ? "none" : c;
                opt.textContent = c === null ? "None" : c;
                input.appendChild(opt);
              });
              input.value = spec.default;
            } else if (spec.type === "bool") {
              input = document.createElement("input");
              input.type = "checkbox"; input.name = fieldId; input.id = fieldId;
              if (spec.default === true) input.checked = true;
            } else {
              input = document.createElement("input");
              input.type = "number"; input.name = fieldId; input.id = fieldId;
              if (spec.min !== undefined) input.min = spec.min;
              if (spec.max !== undefined) input.max = spec.max;
              input.step = (spec.type === "float") ? "any" : (spec.step !== undefined ? spec.step : 1);
              if (spec.default === null || spec.default === undefined) {
                input.placeholder = "None";
              } else {
                input.value = spec.default;
              }
            }

            wrap.appendChild(label);
            wrap.appendChild(input);
            grid.appendChild(wrap);
          });

          hpFields.appendChild(grid);

          // Prefill once with PRE_HP if it matches current model
          if (!didPrefillOnce && PRE_HP && Object.keys(PRE_HP).length > 0) {
            Object.entries(PRE_HP).forEach(([k, v]) => {
              const el = document.getElementById("hp_" + k);
              if (!el) return;
              if (el.tagName.toLowerCase() === "select") {
                el.value = String(v);
              } else if (el.type === "checkbox") {
                el.checked = Boolean(v);
              } else {
                el.value = v;
              }
            });
            didPrefillOnce = true;
          }

          // re-validate on changes
          hpFields.querySelectorAll("input,select").forEach(el => {
            el.addEventListener("input", validateCombos);
            el.addEventListener("change", validateCombos);
          });

          validateCombos();
        }

        function setDisabled(disabled) {
          [
            taskSelectV,
            document.getElementById("target_column-train"),
            modelSelect,
            splitMode,
            document.getElementById("test-size"),
            document.getElementById("val-size"),
            document.getElementById("shuffle"),
            document.getElementById("stratify"),
            document.getElementById("random-state")
          ].forEach(el => { if (el) el.disabled = disabled; });
          hpFields.querySelectorAll("input, select, textarea").forEach(el => el.disabled = disabled);
          changeBtn.style.display = disabled ? "inline-block" : "none";
        }

        function init() {
          renderModels();

          // If backend set a pre-selected model, keep it
          if (PRE_SELECTED_MODEL) {
            modelSelect.value = PRE_SELECTED_MODEL;
          }

          renderHyperparams();
          updateSplitVisibility();

          // Lock if the server says so
          const isLocked = "{{ locked|default:False }}".toString() === "True";
          if (isLocked) setDisabled(true);

          changeBtn.addEventListener("click", () => setDisabled(false));
          modelSelect.addEventListener("change", () => { didPrefillOnce = false; renderHyperparams(); });
          taskSelectV.addEventListener("change", () => { renderModels(); didPrefillOnce = false; renderHyperparams(); updateSplitVisibility(); });
          splitMode.addEventListener("change", updateSplitVisibility);
        }

        init();
      });
      </script>
    </section>
  {% endif %}

  {% if model_label %}
    <section>
      <h3>Model Info</h3>
      <p><strong>The model being implemented is:</strong> {{ model_label }}</p>
    </section>
  {% endif %}

  {% if evaluation_result %}
    <section>
      <h3>Model Evaluation Result</h3>
      {% if task == "classification" %}
        <p><strong>Accuracy:</strong> {{ evaluation_result.accuracy }}</p>
        <p><strong>Precision:</strong> {{ evaluation_result.precision }}</p>
        <p><strong>Recall:</strong> {{ evaluation_result.recall }}</p>
        <p><strong>F1-Score:</strong> {{ evaluation_result.f1_score }}</p>
      {% elif task == "regression" %}
        <p><strong>Mean Absolute Error:</strong> {{ evaluation_result.mae }}</p>
        <p><strong>Mean Squared Error:</strong> {{ evaluation_result.mse }}</p>
        <p><strong>Root Mean Squared Error:</strong> {{ evaluation_result.rmse }}</p>
        <p><strong>R² Score:</strong> {{ evaluation_result.r2 }}</p>
      {% endif %}
    </section>
  {% endif %}

  <!-- Reset / Start over button at the very end -->
  <section>
    <form method="post" class="form-block">
      {% csrf_token %}
      <button type="submit" name="reset" value="1" class="btn"
              style="background:#fff3cd; border-color:#ffe69c; color:#000;">
        Reset Session
      </button>
    </form>
  </section>

</div>
{% endblock %}